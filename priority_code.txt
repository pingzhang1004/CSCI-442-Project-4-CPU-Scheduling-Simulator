priority_algorithm.cpp:


PRIORITYScheduler::PRIORITYScheduler(int slice) {
    if (slice != -1) {
        throw("PRIORITY must have a timeslice of -1");
    }
}

std::shared_ptr<SchedulingDecision> PRIORITYScheduler::get_next_thread() {
    auto next_thread = std::make_shared<SchedulingDecision>(); 
    if (!this->size()) {
        next_thread->explanation = "No threads available for scheduling.";
        return next_thread;
    }
    next_thread->thread = priority_queue.top();
    priority_queue.pop();
    // Explanation here 
    nums[next_thread->thread->priority]--;
    // Explanation here
    return next_thread;
}

void PRIORITYScheduler::add_to_ready_queue(std::shared_ptr<Thread> thread) {
    priority_queue.push(thread->priority, thread);
    nums[thread->priority]++;
}

size_t PRIORITYScheduler::size() const {
    return priority_queue.size();
}


priority_algorithm.hpp:


PriorityQueue priority_queue;
int nums[4];